## 14-1 람다식(Lambda Expression)

- `함수(메서드)를 간단한 "식(expression)" 으로 표현하는 방법`

  간단한!! 이 키워드임

  

- 익명 함수(이름이 없는 함수, anonymous function)

  기존의 함수에서 return 타입, 함수 이름을 없애고 화살표를 넣으면 된다

  

- 함수와 메서드의 차이

  1. 근본적으로 동일. 함수는 일반적 용어, 메서드는 객체지향개념 용어
  2. 함수는 클래스에 독립적, 메서드는 클래스에 종속적



## 14-2 람다식 작성하기

1. 메서드의 이름과 반환타입을 제거하고 '->' 를 블록 {} 앞에 추가한다.

   

2. 반환값이 있는 경우, 식이나 값만 적고 return 문 생략 가능 (끝에 ' ; ' 안 붙임)

   ```java
   (int a, int b) -> a > b ? a : b
   ```

   

3. 매개변수의 타입이 추론 가능하면 생략가능(대부분의)

   <img src="람다식추론가능.png" />

   

## 14-3 람다식 작성하기 - 주의사항

1. 매개변수가 하나인 경우, 괄호() 생략 가능 ( but 타입이 없을 때만!!!)

   <img src="람다식소괄호생략.png" />

   

2. 블록 안의 문장이 하나뿐일 때, 괄호 {} 생략 가능!!

   단, 하나뿐인 문장이 return 문이면 괄호{} 생략 불가

   <img src="람다식대괄호생략.png" />

   근데 return 쓸 일이 거의 없으니 그냥 보기만 하라고 하심

   

## 14-3 람다식의 예

| 메서드                                                       | 람다식                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| int max(int a, int b) {<br />     return a>b ? a: b<br />}   | (a, b) -> a > b ? a : b                                      |
| int printVar(String name, int i) {<br />     System.out.println(name + "=" + i)<br />} | (String name, int i) -> System.out.println(name + "=" + i) 라고 생각을 했으나...<br />(name, i) -> System.out.println(name + "=" + i) 이렇게 생략이 가능 |
| int square(int x) {<br />     return x * x<br />}            | x -> x * x                                                   |
| int roll() {<br />     return (int)(Math.random() * 6)<br />} | () -> (int)(Math.random() * 6)                               |



## 14-4 람다식은 익명 함수? 사실은 익명 객체!

<img src="람다식은익명객체.png" />

- 람다식은 사실 익명 함수가 아니라 익명 객체이다.

  `자바 에서는 메서드만 따로 존재할 수가 없으니까!!`

  

- 람다식(익명 객체)을 다루기 위한 참조변수가 필요. 참조 변수의 타입은?

  Object 이다! 익명 객체는 Object 타입이니까



- 근데 그러면 위의 그림처럼 문제가 하나 생긴다.

  참조변수 타입은 Object 로 하는게 맞다. new Object() 를 가르켜야 하니까

  근데 Object 타입 참조 변수로는 max() 를 쓸 수 없다. 이에 대한 해결책이 필요함

  그걸 14-4 에서 알랴줄꺼!



## 14-5 함수형 인터페이스

- 함수형 인터페이스 - 단 하나의 추상 메서드만 선언된 인터페이스

  ```java
  @FunctionalInterface		
  interface MyFunction {
      public abstract int max(int a, int b);
  //   public abstract int max2(int a, int b);		이게 불가능해짐!
  }
  
  MyFunction f = new MyFunction(){
      public int max(int a, int b){
          return a > b ? a : b;
      }
  }
  
  int value = f.max(3,5);
  
  ```

  @FunctionInterface 를 붙이게 되면, 추상 메서드를 1 개만 들어올 수 있게 컴파일러가 잡아줌!



- 함수형 인터페이스 타입의 참조변수로 람다식을 참조할 수 있음.

  `(단, 함수형 인터페이스의 메서드와 람다식의 매개변수 개수와 return 타입이 일치해야 한다)`

  ```java
  MyFunction f = (a,b) -> a > b ? a : b;	// 람다식. 익명객체
  int value = f.max(3,5);
  ```

  

- 참조) Ex14_0 



## 14-5 함수형 인터페이스 - example

- 익명 객체를 람다식으로 대체

  ```java
  List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");
  
  Collections.sort(list, new Comparator<String>(){
      public int compare(String s1, String s2){
          return s2.compareTo(s1);
      }
  })
  ```

  지금까지는 list 에 sort 를 쓰려면 위와 같이 바로 Comparator 객체를 생성해서 집어넣어야 했다.

  하지만 Comparator 는 코드상 다음과 같이 구현되어 있다.

  ```java
  @FunctionalInterface
  interface Comparator<T> {
      public abstarct compare(T o1, T o2);
  }
  ```

  그래서 다음과 람다식을 이용하면 다음과 같이 나타낼 수 있다

  ```java
  List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");
  
  Collections.sort(list, (s1, s2) -> s2.compareTo(s1));
  ```

  

## 14-6 함수형 인터페이스 타입의 매개변수, 반환타입

- 함수형 인터페이스 타입의 매개변수 

  ```java
  @FunctinalInterface
  interface MyFunction {
      public abstarct void myMethod();
  }
  
  void aMethod(MyFunction f) {	//
      f.myMethod();	// MyFunction 에 정의된 메서드 호출 == 람다식 호출
  }
  
  MyFunction f =  () -> System.out.println("myMethod()");		
  aMethod(f);	// 이렇게 써도 되고
  
  aMethod(() -> System.out.println("myMethod()"));
  ```

  

- 함수형 인터페이스 타입의 return 타입

  ```java
  MyFunction myMethod() {
      MyFunction f = () -> {};
      return f;
  }
  
  MyFunction myMethod() {
      return () -> {};
  }
  ```

  

- 참조) Ex14_1



## 14-7 java.util.function 패키지 (1/3)

- 자주 사용되는 다양한 함수형 인터페이스를 제공

  <img src="다양한함수형인터페이스.png" />

  마지막은 Predicate 인터페이스의 예시를 보여준 것.

  

- 퀴즈

  <img src="함수형인터페이스퀴즈.png" />

  

## 14-7 java.util.function 패키지 (2/3)

- 매개변수가 2개인 함수형 인터페이스

  <img src="매개변수2개함수형인터페이스.png" />

  매개변수가 3개인 경우네느 따로 선언을 해야함



## 14-7 java.util.function 패키지 (3/3)

- 매개변수의 타입과 반환타입이 일치하는 함수형 인터페이스

  <img src="인풋과리턴의타입일치.png" />

  

- UnaryOperator<T> 구현 된거

  <img src="UnaryOperator구현.png" />



- 참조)Ex14_2



## 14-9 Predicate 의 결합

- and(), or(), negate() 로 두 Predicate 를하나로 결합 `default 메서드`

  원래는 추상메서드 1 개 밖에 없다. 

  하지만 인터페이스는 static 메서드, default 메서드들도 추가가 가능함

  ```java
  Predicate<Integer> p = i -> i < 100;
  Predicate<Integer> q = i -> i < 200;
  Predicate<Integer> r = i -> i % 2 == 0;
  
  Predicate<Integer> notP = p.negate();			i >= 100
  Predicate<Integer> all = notP.and(q).or(r);		 100 <= i && i < 200 || i % 2 == 0
  Predicate<Integer> all2 = notP.and(q.or(r));	 100 <= i %% ( i < 200 || i % 2 == 0 )
  ```

  ```java
  System.out.println(all.test(2));		// 이게 왜 true?
  System.out.println(all2.test(2));		// 이게 왜 false?
  ```

  

- 등가비교를 위한 Predicate의 작성에는 isEqual() 를 사용 `static 메서드`

  ```java
  Predicate<String> p = Predicate.isEqual(str1)		isEqual() 은 static 메서드
  Boolean result = p.test(str2);						 str1 과 str2 가 같은 지 비교한 결과를 반환
  
  boolean result = Predicate.isEqual(str1).test(str2);
  ```

  근데 이거는 안 외워도 되고, 그냥 필요할 때 보고 하자

  

- 참조) Ex14_4

  

## 14-11 컬렉션 프레임웍과 함수형 인터페이스

- 함수형 인터페이스를 사용하는 컬렉션 프레임웍의 메서드 ( 와일드 카드 생략 )

  <img src="컬렉션프레임웍함수형인터페이스.png" />

  

- 참조) Ex14_4



## 14-13 메서드 참조 (method reference)

<img src="메서드참조static.png" />

- `클래스이름::메서드이름` 

- 하나의 메서드만 호출하는 람다식은 `메서드 참조` 로 `더 간단히 할 수 있다`

  ​	

- static 메서드 참조

  만약 메서드 참조가 이해가지 않는 다면, 

  역으로 람다식으로 바꿔서 이해해보려고 하자



- 다 외울 필요 없다! 

  책 보면서 할 수 있으면 충분함!



- 참조) Ex14_0_0 



## 14-14 생성자의 메서드 참조

- 생성자와 메서드 참조

  ```java
  Supplier<MyClass> s = () -> new MyClass();
  
  Suppler<MyClass> s = MyClass::new;
  ```

  

  이거 보면 생성자에 매개변수가 필요한 경우이다

  ```java
  Function<Integer, MyClass> s = i -> new MyClass(i);	
  
  Function<Integer, MyClass> s = MyClass::new;
  ```

  결과는 위에와 같다. 

  다만 이 경우 함수형 인터페이스는 Function, 즉 input 이 존재한다.

  

  그래서 이런 경우, Integer 타입 변수 하나가 생성자의 매개변수로 들어간다는 얘기이다!

  만약 2 개의 매개변수가 필요하면, BiFunction 인터페이스를 사용하면 됨!

  

- 배열과 메서드 참조

  ```java
  Function<Integer, int[]> f = x -> new int[x];			람다식
  
  Function<Integer, int[]> f2 = int[]::new;
  ```

  

- 참조) Ex14_0_1

  

## 14-15 스트림(Stream)

<img src="스트림전체과정.png" />

- `다양한 데이터 소스==컬렉션, 배열`를 표준화된 방법으로 다루기 위한 것

  

- 스트림을 사용하는 것은 크게 3 가지의 과정으로 볼 수 있다.

  1. 스트림 생성
  2. 중간연산 ( 0 ~ n 번 )
  3. 최종연산 ( 0 ~ 1 번 )

  

- 스트림 과정 예시

  <img src="스트림과정예시.png" />

  

## 14-16 스트림(Stream) 의 특징 (1/3)

- 밑에 나오는 세부적인 코드 부분은 아직 몰라도 된다! 그냥 흐름만 이해하자!

  

- 스트림은 데이터 소스로부터 데이터를 읽기만할 뿐 변경하지는 않는 다!

  ```java
  List<Integer> list = Arrays.asList(3,1,5,4,2);
  List<Integer> sortedList = list.stream().sorted()			list 를 정렬
      					.collect(Collectors.toList());		   새로운 List 에 저장
  System.out.println(list);									  [3, 1, 5, 4, 2]
  System.out.println(sortedList);								 [1, 2, 3, 4, 5]
  ```

  

- 스트림은 Iterator 처럼 일회용이다. 따라서 필요하면 다시 스트림을 생성해야 한다.

  ```java
  strStream.forEach(System.out::println);				모든 요소를 화면에 출력 (최종연산)
  int numOfStr = strStream.count();				   에러. 스트림이 이미 닫혔음.
  ```

  

- 최종 연산 전까지 중간연산이 수행되지 않는 다. - 지연된 연산

  ```java
  IntStream intStream = new Random().ints(1, 46);			 1~45 범위의 무한 스트림
  intStream.distinct().limit(6).sorted()						   중간 연산
  		.forEach(i -> System.out.print( i + ", "));			   최종 연산
  ```

  스트림의 종류에는 크게 2 가지이다.

  1. 유한 스트림
  2. 무한 스트림

  위의 코드에서 intStream 은 무한 스트림인데, 중복 제거+정렬을 실행함.

  이건 말이 안되지만, 컴파일러는 에러를 잡아내지 않는 다.

  

  왜냐하면, 스트림은 최종 연산을 하지 않으면 

  중간 연산을 표시만 해뒀다가, 나중에 필요할 때 실행을 하기 때문이다!



## 14-16 스트림(stream) 의 특징 (2/3)

<img src="스트림특징2번째.png" />

반복문으로 한번 하면 될걸

위처럼 구현하게 되면 성능이 떨어지게 된다.



하지만 이처럼 해두면, 코드를 쓸 때 간결해진다는

장점이 있다!



## 14-16 스트림(stream) 의 특징 (3/3)

- 스트림의 작업을 병렬로 처리 - 병렬스트림 ( 멀티쓰레드! )

  ```java
  Stream<String> strStream = Stream.of("dd", "aaa", "CC", "cc", "b");
  int sum = strStream.parallel()			// 병렬 스트림으로 전환함 (속성만 변경)
      				.mapToInt(s -> s.length()).sum();			// 모든 문자열의 길이의 합
  ```

  병렬스트림을 다시 되돌려 놓고 싶으면

  sequential()!

  

- 기본형 스트림 - IntStream, LongStream, DoubleStream

  1. 오토방식 & 언박싱 의 비효율이 제거됨 (Strean<Integer> 보다 IntStream) 사용

  2. 숫자와 관련된 유용한 메서드를 Stream<T> 보다 더 많이 제공

  3. 근데 기본형 스트림 은 1 번만 잘 알고, 쓸 일은 거의 없다고 하심

     만약 성능이 너무 느리다 싶으면, 그때 기본형 스트림을 고려해보라고 함.



## 14-17 스트림 만들기 - 컬렉션

